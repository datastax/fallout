buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }

    dependencies {
        classpath 'guru.nidi:graphviz-java:0.18.1'
        classpath 'net.sourceforge.plantuml:plantuml:1.2021.4'
    }
}

plugins {
    id 'java'

    // This is both a library _and_ an application
    id 'java-library'
    id 'application'

    id 'jacoco'
    id "idea"

    id "com.datastax.fallout.symlinks"
    id "com.datastax.fallout.externaltools"
    id "com.datastax.fallout.fork"
    id "com.datastax.fallout.git"
    id "com.datastax.fallout.docker"
    id "com.datastax.fallout.conventions.test"
    id "com.datastax.fallout.conventions.lint"
    id "com.datastax.fallout.conventions.kotlin"
    id "com.datastax.fallout.conventions.dependency-locking"
    id "com.datastax.fallout.conventions.common-root-project"

    id "com.github.johnrengelman.shadow" version "7.1.1"
    id "com.github.node-gradle.node" version "3.1.1"
    id "com.diffplug.spotless" version "6.2.0"

    // This appears to be the only assertj plugin that:
    // - handles dependencies correctly;
    // - generates a single entrypoint class;
    // - can generate assertions for non-project classes.
    id "com.waftex.assertj-generator" version "1.1.4"
}

import com.datastax.fallout.gradle.fork.Fork
import static com.datastax.fallout.gradle.Utils.camelCase
import static com.datastax.fallout.gradle.common.CascadeTaskKt.cascadeTask

group = 'com.datastax'
version = '0.1.0-SNAPSHOT'
mainClassName = 'com.datastax.fallout.service.FalloutService'

def javaModuleJvmArgs = [
        // Handle jackson reflection under Java 9+ (see
        // https://github.com/FasterXML/jackson-modules-base/issues/37#issuecomment-389581245)
        '--add-opens', 'java.base/java.lang=ALL-UNNAMED',
        '--add-opens', 'java.base/java.nio=ALL-UNNAMED'
]

// This will be inserted into the fallout wrapper script
applicationDefaultJvmArgs = [
        '-XX:+HeapDumpOnOutOfMemoryError',
        '-XX:-OmitStackTraceInFastThrow',
        '-server',
        '-ea',
        '-Djava.util.concurrent.ForkJoinPool.common.parallelism=1024'
] + javaModuleJvmArgs

// In production, falloutctl sets heap sizes; when running within gradle
// we must set something larger than the default 512m
// (https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory)
// for the test and server processes:
ext.applicationGradleJvmArgs = applicationDefaultJvmArgs + ["-Xmx2G"]

description = """DataStax Fallout"""

def defaultPropertyValue(String name, Closure valueProvider) {
    if (!project.hasProperty(name)) {
        ext.set(name, valueProvider.call())
    }
    ext.get(name)
}

def defaultPropertyValue(String name, Object value) {
    defaultPropertyValue(name, { value })
}

allprojects {
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
        if (rootProject.hasProperty('showJavaCompilerWarnings')) {
            options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
        }
    }

    // Ensure that archive tasks have reproducible outputs: this allows
    // build caching and build avoidance.  See
    // https://docs.gradle.org/5.6.3/userguide/working_with_files.html#sec:reproducible_archives
    tasks.withType(AbstractArchiveTask) {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    tasks.withType(Zip) {
        zip64 = true
    }

    tasks.withType(JavaExec) {
        enableAssertions = true
    }
}

def dropwizardVersion = '2.0.+'

ext.jschVersion = "0.2.4"

defaultTasks ':shadowJar'

sourceSets {
    testBase
    integrationTest
    cassandraAllShaded
}

configurations {
    testBaseImplementation.extendsFrom(implementation, testConventionsImplementationDeps)

    integrationTestImplementation.extendsFrom(testBaseImplementation)
    integrationTestRuntimeOnly.extendsFrom(testBaseRuntimeOnly, testConventionsRuntimeOnlyDeps)
    integrationTestCompileOnly.extendsFrom(testBaseCompileOnly)

    testImplementation.extendsFrom(testBaseImplementation)
    testRuntimeOnly.extendsFrom(testBaseRuntimeOnly, testConventionsImplementationDeps)
    testCompileOnly.extendsFrom(testBaseCompileOnly)
}

// Make the following sourceSets available
// for consumption as feature variants; see
// https://docs.gradle.org/current/userguide/cross_project_publications.html#sec:variant-aware-sharing
java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(17))

    registerFeature("testBase") {
        usingSourceSet(sourceSets.testBase)
    }
    registerFeature("test") {
        usingSourceSet(sourceSets.test)
    }
    registerFeature("cassandraAllShaded") {
        usingSourceSet(sourceSets.cassandraAllShaded)
    }
    registerFeature("integrationTest") {
        usingSourceSet(sourceSets.integrationTest)
    }
}

configurations.all {
    resolutionStrategy {
        // The transitive dependency
        // io.dropwizard.metrics:metrics-jersey2:4.1.28 brings in jersey-server
        // 2.35, while io.dropwizard:dropwizard-core depends on jersey
        // 2.33; the combination of the two versions causes SSE failures
        force("org.glassfish.jersey.core:jersey-server:2.33")
    }
}

dependencies {
    // The DataStax internal version of fallout uses this project as a
    // dependency, which is why several dependencies are exposed as api
    // dependencies rather than implementation dependencies

    api project(path: ':cassandra-all-shaded', configuration: 'shadow')
    api project(path: ':jepsen', configuration: 'shadow')

    cassandraAllShadedApi project(path: ':cassandra-all-shaded', configuration: 'shadow')

    api(platform("io.dropwizard:dropwizard-bom:${dropwizardVersion}"))
    api(platform("io.dropwizard:dropwizard-dependencies:${dropwizardVersion}"))
    api "io.dropwizard:dropwizard-core"
    implementation "io.dropwizard:dropwizard-views-mustache"
    implementation "io.dropwizard:dropwizard-assets"
    api "io.dropwizard:dropwizard-auth"
    api "io.dropwizard:dropwizard-logging"
    api "io.dropwizard:dropwizard-metrics-graphite"

    api(platform("com.fasterxml.jackson:jackson-bom:2.12.+"))
    api("com.fasterxml.jackson.core:jackson-databind")

    api "com.google.guava:guava"
    api "com.github.spullara.mustache.java:compiler"

    implementation "org.eclipse.jetty:jetty-rewrite"
    implementation "com.github.mwiede:jsch:${jschVersion}"

    api "commons-io:commons-io:2.+"
    api "org.yaml:snakeyaml:1.+"
    implementation("com.h2database:h2:1.4.+") {
        because("InMemoryCsvCheck uses this")
    }
    implementation "javax.mail:javax.mail-api:1.6.+"
    implementation "com.sun.mail:javax.mail:1.6.+"
    api "org.apache.commons:commons-csv:1.+"
    api("io.netty:netty-common:4.1.+") {
        because "HashedWheelTimer is used in several places"
    }
    implementation "com.fasterxml.jackson.core:jackson-annotations"
    implementation("org.apache.httpcomponents:httpclient:4.+") {
        because "HttpUtils is the only user; everything else uses jersey"
    }

    api "org.hdrhistogram:HdrHistogram:2.+"
    api 'com.github.pingtimeout:HdrLogProcessing:274e279'

    // Swagger
    implementation("io.dropwizard:dropwizard-views-freemarker") {
        because "Freemarker rendering is used by the dropwizard swagger bundle"
    }

    // See https://github.com/smoketurner/dropwizard-swagger/releases
    //
    // Waiting for fix of
    // https://github.com/smoketurner/dropwizard-swagger/issues/210 to be
    // released in an official version.  Once that has
    // been done, we can use that instead of this jitpack dependency,
    implementation("com.github.smoketurner:dropwizard-swagger:661c79d")

    // Server-Sent Events
    implementation "org.glassfish.jersey.media:jersey-media-sse"
    implementation("org.glassfish.jersey.security:oauth2-client") {
        // Prevent the Jersey JacksonFeature (which overrides the Dropwizard
        // one) from being found and registered.
        // See https://github.com/dropwizard/dropwizard/issues/1341
        exclude(group: "org.glassfish.jersey.media", module: "jersey-media-json-jackson")
    }
    implementation "javax.ws.rs:javax.ws.rs-api:2.+"

    implementation('com.google.cloud:google-cloud-logging:2.2.+') {
        exclude group: 'com.google.guava', module: 'guava'
    }

    // AutoService
    def autoServiceVersion = '1.+'
    annotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"
    testAnnotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"
    testBaseAnnotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"

    implementation "com.google.auto.service:auto-service-annotations:${autoServiceVersion}"

    // Compile against the main classes, but leave it up to the
    // test configuration to specify where the runtime is (test
    // will already use sourceSets.main.output by default).
    testBaseCompileOnly sourceSets.main.output

    testBaseApi "org.awaitility:awaitility"

    testBaseApi(platform("io.dropwizard:dropwizard-bom:${dropwizardVersion}"))
    testBaseApi(platform("io.dropwizard:dropwizard-dependencies:${dropwizardVersion}"))

    testBaseImplementation "io.dropwizard:dropwizard-logging"
    testBaseApi("io.dropwizard:dropwizard-testing") {
        exclude group: "junit", module: "junit"
    }

    testImplementation sourceSets.testBase.output
    testApi "org.apache.sshd:sshd-core:2.+"
    testApi "org.apache.sshd:sshd-sftp:2.+"
    testApi "org.apache.sshd:sshd-scp:2.+"
    testApi "org.mockito:mockito-core:4.+"
    testApi 'org.mockito:mockito-junit-jupiter:4.+'
    testApi "org.quicktheories:quicktheories:0.+"
    testImplementation('com.github.tomakehurst:wiremock-jre8:2.+') {
        exclude group: 'com.fasterxml.jackson'
    }
    // Needed for ClojureShutdownListener
    testImplementation "org.junit.platform:junit-platform-launcher"

    integrationTestImplementation sourceSets.testBase.output
    integrationTestRuntimeOnly tasks.jar.outputs.files

    implementation 'software.amazon.awssdk:s3:2.17.259'
    implementation 'software.amazon.awssdk:secretsmanager:2.17.259'
    implementation 'software.amazon.awssdk:ses:2.17.259'
}

// ----------------------------------------------------------------------------
// Git support

task setupGit {
    def config = [
            "core.hooksPath" : "git-hooks",
            "core.whitespace": "blank-at-eol,space-before-tab,tab-in-indent,trailing-space"
    ]
    doLast {
        config.each { key, value ->
            exec {
                commandLine("git", "config", key, value)
            }
        }
        exec {
            commandLine("git", "secrets", "--register-aws")
        }
        exec {
            commandLine("git", "secrets", "--add-provider", "--",
                    "grep", "-E", "-v", "^[[:space:]]*(#.*)?\$", ".gitforbidden")
        }
    }
}

// ----------------------------------------------------------------------------
// Compilation

// Supporting @JsonCreator with implicit named parameters requires
// that we store the parameter names in the generated class files
// (https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html):
tasks.withType(JavaCompile) {
    options.compilerArgs += '-parameters'
}

// ----------------------------------------------------------------------------
// IDEA integration

idea {
    module {
        // Exclude directories that are ignored in .gitignore; this should be
        // automatic, but it isn't: see
        // https://youtrack.jetbrains.com/issue/IDEA-140714
        excludeDirs += [
                // Ignore files created by running fallout/cassandra in
                // the current directory
                file('tests'), file('cassandra'), file('run'), file('logs'),

                // Nothing creates tmp, but it's a convenient place to keep
                // temporary things
                file('tmp')
        ]
    }
}

def ideaVersion = System.getProperty('idea.version')

if (ideaVersion) {

    def (major, minor) = ideaVersion.split("\\.").collect { it.toInteger() }

    // IDEA 2019 defines idea.version for _all_ gradle invocations; prior
    // versions only defined it when importing.  2019 additionally
    // defines sync.active when importing.
    def importing = major < 2019 || System.getProperty('idea.sync.active');

    if (importing) {

        println "Detected IDEA ${ideaVersion} Sync"

        // IDEA used to incorrectly use the annotation processor classpath as
        // "Provided", which means that any library versions in the annotation
        // processor classpath override the versions in the implementation
        // classpath.  This is no longer the case in 2020.3; it may have
        // been fixed earlier
        if (major < 2020 || (major == 2020 && minor < 3)) {
            println "Fixing incorrect annotation processor classpaths"
            dependencies {
                annotationProcessor configurations.implementation
                testAnnotationProcessor configurations.testImplementation
            }
        }

        // IDEA < 2019.3 searches for annotation processors on the classpath,
        // and doesn't use the annotationProcessor configuration,
        // so we add it here.
        if (major < 2019 || (major == 2019 && minor < 3)) {
            println "Adding annotation processor classpaths"
            idea {
                module {
                    scopes.each {
                        it.value.plus += [configurations.annotationProcessor]
                    }
                }
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Convenience

task publish {
    group 'publish'
    description "Publish all artifacts that make up a release"
}

// ----------------------------------------------------------------------------
// Run cassandra as a standalone process

def cassandraVersion = "2.1.21"

configurations {
    cassandraStandalone
}

dependencies {
    cassandraStandalone 'org.jmxtrans.agent:jmxtrans-agent:1.2.8'
    cassandraStandalone "org.apache.cassandra:cassandra-all:${cassandraVersion}"
}

// Dummy rendezvous task
task cassandraStopped

task startCassandra(type: Fork) {
    def pidFile = file("${project.rootDir}/run/cassandra.pid")
    def java8Home = System.getenv('JAVA8_HOME')
    def classPath = configurations.cassandraStandalone.asPath
    def cassandraYaml = "${project.rootDir}/src/main/resources/cassandra.yaml"
    def logbackXml = "${project.rootDir}/etc/cassandra/logback.xml"
    def logDir = "${project.rootDir}/logs/cassandra"

    doFirst {
        if (!java8Home) {
            throw new GradleException("JAVA8_HOME must be set to run startCassandra task")
        }
    }

    workingDir "${project.rootDir}"
    commandLine "${java8Home}/bin/java",
            "-classpath", classPath,
            "-XX:+HeapDumpOnOutOfMemoryError", "-Xms8G", "-Xmx8G", "-server", "-ea",
            "-Dcassandra.config=file://${cassandraYaml}",
            "-Dcassandra-pidfile=${pidFile}",
            "-Dcassandra.logdir=${logDir}",
            "-Dlogback.configurationFile=${logbackXml}",
            "org.apache.cassandra.service.CassandraDaemon"

    doLast {
        def waitSeconds = 60
        def port = 9096
        def portOpened = false

        while (!portOpened && waitSeconds && !processHandle.state.terminal) {
            try {
                def socket = new Socket("localhost", port);
                socket.close()
                portOpened = true
            }
            catch (ConnectException e) {
            }
            waitSeconds -= 1
            Thread.sleep(1000)
        }

        if (processHandle.state.terminal) {
            throw new GradleException("Cassandra exited with code ${processHandle.waitForFinish().exitValue}")
        }

        if (!portOpened) {
            processHandle.abort()
            throw new GradleException("Cassandra didn't start listening on ${port} within ${waitSeconds} seconds")
        }
    }
}

task stopCassandra {
    finalizedBy cassandraStopped
    doFirst {
        startCassandra.processHandle.abort()
        startCassandra.processHandle.waitForFinish()
    }
}

// ----------------------------------------------------------------------------
// Git

git.describeTagPattern = "fallout-*.*.*"

// ----------------------------------------------------------------------------
// Generated resources

def generatedResourcesOutputDir = file("${buildDir}/src/main/resources")

sourceSets {
    main {
        resources {
            srcDirs += generatedResourcesOutputDir
        }
    }
}

// LESS

node {
    download = true
    version = "16.1.0"

    // Prevent the node extension from declaring a repository: see
    // https://github.com/node-gradle/gradle-node-plugin/blob/6f03c21e7e51189885a384ab533ee191c971f7dc/docs/faq.md#is-this-plugin-compatible-with-centralized-repositories-declaration
    distBaseUrl = null
}

task lessCompile(type: NpxTask) {
    dependsOn npmInstall
    def source = file("src/main/resources/assets/less/fallout.less")
    def target = file("${generatedResourcesOutputDir}/assets/css/fallout.css")

    // The lessCompile task doesn't declare inputs or outputs, so we do it here
    inputs.files fileTree("src/main/resources/assets/less")
    outputs.file target

    command = "lessc"
    args = ["$source", "$target"]
}

processResources.dependsOn(lessCompile)

// Version HTML file

task generateVersionFile() {
    ext.target = file("${generatedResourcesOutputDir}/assets/pages/version.html")
    ext.targetContent = """
        <dl>
        <dt>branch:
        <dd><a href="https://github.com/${git.repo}/tree/${git.branch}">${git.branch}</a>
        <dt>commit:
        <dd><a href="https://github.com/${git.repo}/commit/${git.commit}">${git.commit}</a>
        </dl>
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

// fallout-client installers

task generateCliInstaller() {
    ext.target = file("${generatedResourcesOutputDir}/assets/installers/cli")
    ext.targetContent = """
        pipx install --python python3 --force "git+ssh://git@github.com/${git.repo}.git@${git.commit}#egg=fallout-client&subdirectory=fallout-cli"
    """

    inputs.property('content', targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

task generateApiInstaller() {
    ext.target = file("${generatedResourcesOutputDir}/assets/installers/api")
    ext.targetContent = """
        python3 -m pip install --upgrade "git+ssh://git@github.com/${git.repo}.git@${git.commit}#egg=fallout-client&subdirectory=fallout-cli"
    """

    inputs.property('content', targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

processResources.dependsOn(generateVersionFile, generateCliInstaller, generateApiInstaller)

// ----------------------------------------------------------------------------
// Generated sources

def generatedSourcesOutputDir = file("${buildDir}/src/main/java")

sourceSets {
    main {
        java {
            srcDirs += generatedSourcesOutputDir
        }
    }
}

// Annotation processors

sourceSets.each { sourceSet ->
    if (sourceSet.compileJavaTaskName != null) {
        tasks[sourceSet.compileJavaTaskName].configure {
            options.annotationProcessorGeneratedSourcesDirectory =
                    file("${buildDir}/src/${sourceSet.name}/java-annotation-processors")
        }
    }
}

// Internal version string

task generateVersionJavaFile {
    ext.target = file("${generatedSourcesOutputDir}/com/datastax/fallout/FalloutVersion.java")
    ext.targetContent = """
        package com.datastax.fallout;

        public class FalloutVersion {
            public static String getVersion() { return "${git.describe}"; }
            public static String getCommitHash() { return "${git.commit}"; }
        }
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

compileJava.dependsOn(generateVersionJavaFile)

// ----------------------------------------------------------------------------
// AssertJ custom assertion generation

assertjGenerator {
    classOrPackageNames = [
            'com.datastax.fallout.harness.TestResult',
            'com.datastax.fallout.ops.NodeGroup',
            'com.datastax.fallout.ops.commands.NodeResponse',
            'com.datastax.fallout.runner.CheckResourcesResult',
            'com.datastax.fallout.service.core.Test',
            'com.datastax.fallout.service.core.TestRun',
            'com.datastax.fallout.service.core.User',
            'javax.ws.rs.core.Response',
            'javax.ws.rs.core.Response$StatusType']

    entryPointPackage = "com.datastax.fallout.assertj"
    outputDir = file("${buildDir}/src/testBase/java")
    testSourceSet = sourceSets.testBase
}

// ----------------------------------------------------------------------------
// Distribution and packaging

["startScripts", "startShadowScripts"]
        .collect { tasks[it] }
        *.configure {

            // Insert FALLOUT_HOME and PATH into the default start script before
            // the final "exec" line that runs java.  It's _possible_ to work out
            // where the java executable is running from within the code, but it's more
            // involved and less reliable than doing it from the wrapper.
            doLast {
                unixScript.text = unixScript.text.replaceFirst(~'(\nexec .*\\s*$)', {
                    '''
    export FALLOUT_DIST="$APP_HOME"
    export FALLOUT_HOME="${FALLOUT_HOME:-$FALLOUT_DIST}"
    export PATH="$FALLOUT_DIST/bin:$PATH"
    ''' + it[0]
                })
            }
        }

// External tools

externalTools {
    configuration("main") {
        binary("kubectl") {

            // See https://kubernetes.io/docs/tasks/tools/install-kubectl
            // for location of binaries and checksums

            platforms(["linux", "darwin"]) {
                source.set("https://dl.k8s.io/release/v1.23.2/bin/${platform}/amd64/kubectl")
            }

            platform("linux") {
                checksum.set("5b55b58205acbafa7f4e3fc69d9ce5a9257be63455db318e24db4ab5d651cbde")
            }

            platform("darwin") {
                checksum.set("e4d0e8b3a5686907f4285cf5caf9cef4a22fc84f813ae6f22890078febf698f1")
            }
        }

        tarball("helm") {
            // https://github.com/helm/helm/releases

            platforms(["linux", "darwin"]) {
                source.set("https://get.helm.sh/helm-v3.8.0-${platform}-amd64.tar.gz")
                unpackedBinDir.set("${platform}-amd64")
            }

            platform("linux") {
                checksum.set("8408c91e846c5b9ba15eb6b1a5a79fc22dd4d33ac6ea63388e5698d1b2320c8b")
            }

            platform("darwin") {
                checksum.set("532ddd6213891084873e5c2dcafa577f425ca662a6594a3389e288fc48dc2089")
            }
        }

        tarball("gcloud") {
            // https://console.cloud.google.com/storage/browser/cloud-sdk-release for all versions;
            // https://cloud.google.com/sdk/docs/install for current

            platforms(["linux", "darwin"]) {
                source.set("https://dl.google.com/dl/cloudsdk/channels/rapid/" +
                        "downloads/google-cloud-sdk-369.0.0-${platform}-x86_64.tar.gz")
                unpackedBinDir.set("google-cloud-sdk/bin")
            }

            platform("linux") {
                checksum.set("b5a60ea86c14452580e2019d33586ab2d5dbcde375870d0a030e6b73e7c06093")
            }

            platform("darwin") {
                checksum.set("8a09c9de7c415bdb6ad09b513138d0dffe113fb22c708e10163342e87f80b300")
            }
        }
    }

    configuration("test") {
        binary("kind") {
            // https://github.com/kubernetes-sigs/kind/releases

            platforms(["linux", "darwin"]) {
                source.set("https://github.com/kubernetes-sigs/kind/releases/download/v0.11.1/kind-${platform}-amd64")
            }

            platform("linux") {
                checksum.set("949f81b3c30ca03a3d4effdecda04f100fa3edc07a28b19400f72ede7c5f0491")
            }

            platform("darwin") {
                checksum.set("432bef555a70e9360b44661c759658265b9eaaf7f75f1beec4c4d1e6bbf97ce3")
            }
        }
    }
}

def currentOs = osdetector.os

defaultPropertyValue("externalTestToolsDir", "${buildDir}/externalTestTools")

["linux", "osx"].each { osName ->

    // The same as the standard distribution plus the external-tools
    distributions.create(osName) {
        contents {
            with distributions.main.contents
            from(project.externalTools.configuration("main").platform(osName).installTask)
        }
    }

    distributions.create(camelCase("shadow", osName)) {
        contents {
            with distributions.shadow.contents
            from(project.externalTools.configuration("main").platform(osName).installTask)
        }
    }
}

distributions.create("native") {
    contents {
        with distributions[currentOs].contents
    }
}

distributions.create("shadowNative") {
    contents {
        with distributions[camelCase("shadow", currentOs)].contents
    }
}

distributions.matching { dist ->
    dist.name == "main" || dist.name == "shadow"
}
        *.contents {

            // Cassandra standalone support
            from(configurations.cassandraStandalone) {
                into('lib/cassandra-standalone')
            }
            from("etc/cassandra") {
                into('lib/cassandra-standalone')
            }
            from("src/main/resources") {
                include "cassandra.yaml"
                into('lib/cassandra-standalone')
            }

            // Include the nginx config support files
            from('etc/nginx') {
                into('nginx')
            }

            // Include tool support scripts
            from('tools/support') {
                into('lib/tools/support')
            }
        }

// Include python sources for tools
subprojects { subproject ->
    subproject.afterEvaluate {
        if (subproject.ext.has('isPythonTool')) {
            distributions
                    .matching { dist ->
                        dist.name == "main" || dist.name == "shadow"
                    }
                    *.contents {
                        from(subproject.toolContents) {
                            into "lib/tools/${subproject.toolCategory}/${subproject.toolName}"
                        }
                    }
        }
    }
}

// Ensure shadowJar correctly merges all the service files and also
// caches the output (it doesn't by default)
shadowJar {
    mergeServiceFiles()

    manifest {
        attributes('Implementation-Version': git.describe)
    }

    outputs.cacheIf { true }
}

// ----------------------------------------------------------------------------
// Docker

docker {
    imageFiles.from(installShadowLinuxDist)
    tagName = "datastax/fallout"
    // Use the git version without the "fallout-" prefix e.g. "fallout-1.2.3" -> "1.2.3"
    tagVersion = git.describe.replaceFirst(/^[a-z-]*/, "")
    composeEnvironment.put("CASSANDRA_VERSION", cassandraVersion)
    if (osdetector.os == "osx") {
        composeEnvironment.put("SSH_AUTH_SOCK", "/run/host-services/ssh-auth.sock")
    }
}

publish.dependsOn(dockerPush)

// ----------------------------------------------------------------------------
// Tests

// Dummy rendezvous task to allow builds that compose this build to
// serialize tests
task allTestsFinished

// Pick up any and all generated coverage files
// https://github.com/gradle/gradle/issues/5898#issuecomment-554600486
jacocoTestReport {
    getExecutionData().setFrom(fileTree(buildDir).include("/jacoco/*.exec"))
}

defaultPropertyValue("testToolsRunDir", "${buildDir}/testToolsRun")

task installToolsForTesting {
    dependsOn(externalTools.installAllNativeTask)
}

subprojects {
    rootProject.installToolsForTesting {
        dependsOn tasks.matching { it.name == "installToolForTesting" }
    }
}

allprojects {
    // Make sure we delete any generated coverage files before running any
    // test; if we don't, then coverage reports can include data from test
    // tasks that weren't run as part of the current gradle invocation
    task cleanJacocoOutputs(type: Delete) {
        delete jacocoTestReport.executionData
    }

    tasks.withType(Test) {
        dependsOn(installToolsForTesting)

        environment "PATH", "${externalTools.nativePath}:${System.getenv('PATH')}"
        environment "FALLOUT_TOOLS_DIR", "${testToolsRunDir}/tools"

        jvmArgs = project.applicationGradleJvmArgs

        [
                "runExpensiveTests",
                "runTestsThatCostMoney",
                "skipCCMTests"
        ].each { property ->
            if (rootProject.hasProperty(property)) {
                systemProperty property, true
            }
        }

        // Pass through any -Plog.... settings as system properties
        // (see LogbackConfigurator.java)
        rootProject.properties.each { k, v ->
            if (k =~ /log\..*/) {
                systemProperty k, v
            }
        }

        // Ensure the whole test framework uses the slf4j bridge by setting it
        // in the below properties file; if we don't do this, then there'll
        // be a period of time where the java.util.logging framework is used
        // before gradle manually installs the slf4j bridge
        systemProperties += [
                'java.util.logging.config.file':
                        "${project.rootDir}/src/testBase/resources/java.util.logging.properties"
        ]

        def jacocoPluginApplied = extensions.findByType(JacocoTaskExtension)
        if (jacocoPluginApplied) {

            // Generating coverage data has a non-negligible runtime cost, so we
            // don't enable it by default
            def generateCoverageData = rootProject.hasProperty('generateCoverageData')

            jacoco {
                enabled = generateCoverageData
            }

            if (generateCoverageData) {
                dependsOn cleanJacocoOutputs
                finalizedBy jacocoTestReport
            }
        }
    }
}

test {
    useJUnitPlatform {
        excludeTags "requires-db"
    }

    testClassesDirs = testClassesDirs.plus(
            sourceSets.testBase.output.classesDirs)

    finalizedBy allTestsFinished
}

task dbTest(type: Test) {
    description = 'Starts a local DB instance and runs tests marked RequiresDb.'
    group = 'verification'

    useJUnitPlatform {
        includeTags "requires-db"
    }

    dependsOn startCassandra
    finalizedBy stopCassandra, allTestsFinished

    mustRunAfter test
}

["check", "cleanCheck"].each { taskName ->
    cascadeTask(project, tasks.named(taskName))
}

// ----------------------------------------------------------------------------
// Running development versions

def nginxStandaloneDir = file("${buildDir}/nginx-standalone")

task generateStandaloneNginxFalloutYml {
    ext.falloutYml = file("fallout.yml")
    ext.generatedFalloutYml = file("${nginxStandaloneDir}/fallout.yml")

    inputs.file falloutYml
    outputs.file generatedFalloutYml

    doLast {
        generatedFalloutYml.getParentFile().mkdirs()
        generatedFalloutYml.withOutputStream { out ->
            if (falloutYml.exists()) {
                falloutYml.withInputStream {
                    out << it.filterLine {
                        !it.contains("useNginxToServeArtifacts")
                    }
                }
            }
            out << "\nuseNginxToServeArtifacts: true"
        }
    }
}

task generateStandaloneNginxConf(type: JavaExec, dependsOn: [compileJava, generateStandaloneNginxFalloutYml]) {
    ext.nginxConf = file("${nginxStandaloneDir}/nginx.conf")
    ext.nginxHtml = file("etc/nginx/html")

    outputs.file nginxConf

    main run.main
    classpath run.classpath
    args 'generate-nginx-conf',
            '--standalone',
            '--nginx-listen-port', '8090',
            '--output', nginxConf,
            generateStandaloneNginxFalloutYml.generatedFalloutYml, nginxHtml
}

task startStandaloneNginx(type: Fork, dependsOn: generateStandaloneNginxConf) {
    commandLine "nginx", "-p", nginxStandaloneDir, "-c", generateStandaloneNginxConf.nginxConf
}

task stopStandaloneNginx {
    doFirst {
        startStandaloneNginx.processHandle.abort()
    }
}

class RunServer extends JavaExec {
    RunServer() {
        main = project.tasks.run.main
        classpath = project.tasks.run.classpath
        group = "application"

        dependsOn(project.tasks.installToolsForTesting)

        environment "PATH", "${project.externalTools.nativePath}:${System.getenv('PATH')}"
        environment "FALLOUT_TOOLS_DIR", "${project.ext.testToolsRunDir}/tools"

        jvmArgs project.applicationGradleJvmArgs
        if (project.hasProperty("devmode")) {
            jvmArgs jvmArgs + ['-Dfallout.devmode=true']
        }
    }
}

task runServerWithNginx(type: RunServer) {
    description "Run the fallout server and nginx, " +
            "using nginx to serve artifacts"

    dependsOn startStandaloneNginx, startCassandra
    finalizedBy stopCassandra, stopStandaloneNginx

    args 'standalone', generateStandaloneNginxFalloutYml.generatedFalloutYml
}

task runServer(type: RunServer) {
    description "Run the fallout server"

    ext.falloutYml = file("fallout.yml")
    inputs.files falloutYml

    dependsOn startCassandra
    finalizedBy stopCassandra

    if (falloutYml.exists()) {
        args 'standalone', falloutYml
    } else {
        args 'standalone'
    }
}
task runServerInDocker {
    group 'docker'
    description "Run the fallout server docker image using docker-compose"

    dependsOn "dockerComposeUp"
    finalizedBy "dockerComposeDown"

    // Gradle won't run finalizers on ctrl-C, and it won't pass the
    // SIGINT thus generated to child processes (it uses destroyForcibly
    // == SIGTERM), so we can't just make this task run plain
    // "docker-compose up" and allow ctrl-C to do graceful shutdown.
    doFirst {
        println "Fallout server is running; press <RETURN> to terminate."
        println "Will start log tailing in a moment..."

        // Give people a chance to see the above message
        Thread.sleep(5000)

        def dockerComposeLogs = project.procs.fork {
            commandLine "docker-compose", "-f", dockerComposeFile, "logs", "--follow"
        }

        System.in.read();

        dockerComposeLogs.abort()
    }
}

// ----------------------------------------------------------------------------
// Create a custom jar with a different FalloutVersion for the purpose of
// deployment testing

def generatedDeploymentTestSourcesOutputDir = file("${buildDir}/src/deploymentTestVersion/java")

sourceSets {
    deploymentTest {
        java {
            srcDirs += generatedDeploymentTestSourcesOutputDir
        }
    }
}

task generateDeploymentTestVersionJavaFile {
    ext.target = file("${generatedDeploymentTestSourcesOutputDir}/com/datastax/fallout/FalloutVersion.java")
    ext.targetContent = """
        package com.datastax.fallout;

        public class FalloutVersion {
            public static String getVersion() { return "DEPLOYMENT_TEST"; }
            public static String getCommitHash() { return "DEPLOYMENT_TEST"; }
        }
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

compileDeploymentTestJava.dependsOn(generateDeploymentTestVersionJavaFile)

// Create a jar that contains all but the FalloutVersion from the main
// sourceset, and the FalloutVersion we build for deployment testing
task deploymentTestJar(type: Jar) {
    from(sourceSets.main.output) {
        exclude "**/FalloutVersion.*"
    }
    from(sourceSets.deploymentTest.output)
    archiveFileName = "fallout-deploymentTest.jar"
}

// ----------------------------------------------------------------------------
// Integration tests

task integrationTest(type: Test, dependsOn: [dockerBuild]) {
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath

    systemProperties([
            dockerLatestTag: docker.latestTag.get(),
            falloutVersion : git.describe
    ])

    mustRunAfter(test, dbTest, stopCassandra)
    finalizedBy allTestsFinished
}

// ----------------------------------------------------------------------------
// Cleanliness

spotless {
    java {
        custom 'prefer generated assertj entry point', { str ->
            str.replace('import static org.assertj.core.api.Assertions.',
                    'import static com.datastax.fallout.assertj.Assertions. ')
        }

        // The spotless import ordering plugin is based on the eclipse one;
        // it's not as advanced as IntelliJ, in that it _always_ inserts a
        // blank line between groups, and matches imports by longest
        // matching prefix: there's no wildcard matching.
        // An empty group ('') matches everything.
        // '\\#' matches static imports.
        //
        // If you change this, you should also change the import order in
        // ij_java_imports_layout in .editorconfig.
        //
        // This ordering is pragmatic rather than anything else; it matches
        // the ordering that most of the codebase already had before we started
        // enforcing it.
        importOrder(
                'javax.', 'java.', '', 'com.datastax.', 'org.apache.cassandra.', '\\#')
        removeUnusedImports()

        endWithNewline()
        trimTrailingWhitespace()
        eclipse().configFile("eclipse-format.prefs")
        licenseHeaderFile "gradle/LicenseHeader.java"

        target "src/*/java/**/*.java"
    }
}

tasks.named("lint").configure {
    dependsOn(spotlessCheck)
}

test {
    shouldRunAfter spotlessCheck
}

// ----------------------------------------------------------------------------
// Diagrams; we use a graphviz library to generate a PNG, and plantuml for
// sequence diagrams

import guru.nidi.graphviz.engine.Graphviz
import guru.nidi.graphviz.engine.Format

task dumpNodeGroupStatesToDot(type: JavaExec) {
    group "documentation"

    ext.dotFile = file("${buildDir}/node-group-states.dot")
    description "Create a DOT diagram of node states in ${dotFile}"

    dependsOn compileJava
    outputs.file dotFile

    main = 'com.datastax.fallout.ops.DumpNodeGroupStatesToDot'
    classpath = sourceSets.main.runtimeClasspath
    args = [dotFile]
}

def renderDotFile(dotFile, pngFile) {
    Graphviz.fromFile(dotFile).render(Format.PNG).toFile(pngFile)
}

task dumpNodeGroupStatesToPng {
    group "documentation"

    dependsOn dumpNodeGroupStatesToDot
    inputs.files dumpNodeGroupStatesToDot
    outputs.file file("docs/node-group-states.png")

    description "Create a PNG diagram of node states in " +
            "${outputs.files.singleFile}"

    doLast {
        renderDotFile(inputs.files.singleFile, outputs.files.singleFile)
    }
}

task renderDocsDots {
    group "documentation"
    description "Creates PNGs from DOT source files in docs/assets"

    inputs.files fileTree(dir: "docs/assets", include: "*.dot")
    outputs.files inputs.files.collect { f -> file(f.path.replace(".dot", ".png")) }
    doLast {
        inputs.files.each { f ->
            renderDotFile(f, file(f.path.replace(".dot", ".png")))
        }
    }
}

// I couldn't make https://github.com/cosminpolifronie/gradle-plantuml-plugin
// work as of 1.6.0, so we're hand-rolling this like the dot support above:

import net.sourceforge.plantuml.SourceStringReader
import net.sourceforge.plantuml.FileFormatOption
import net.sourceforge.plantuml.FileFormat

def renderPlantUmlFile(plantUmlFile, pngFile) {
    pngFile.withOutputStream { out ->
        new SourceStringReader(plantUmlFile.text)
                .outputImage(out, new FileFormatOption(FileFormat.PNG, true))
    }
}

task renderDocsPlantUmls {
    group "documentation"
    description "Creates PNGs from plantuml source files in docs/assets"

    inputs.files fileTree(dir: "docs/assets", include: "*.plantuml")
    outputs.files inputs.files.collect { f -> file(f.path.replace(".plantuml", ".png")) }
    doLast {
        inputs.files.each { f ->
            renderPlantUmlFile(f, file(f.path.replace(".plantuml", ".png")))
        }
    }
}

task docs(dependsOn: [dumpNodeGroupStatesToPng, renderDocsDots, renderDocsPlantUmls]) {
    group "documentation"
    description "Run all documentation tasks except javadoc"
}

// ----------------------------------------------------------------------------

wrapper {
    // https://gradle.org/release-checksums/
    gradleVersion = "7.3.2"
    distributionSha256Sum = "23b89f8eac363f5f4b8336e0530c7295c55b728a9caa5268fdd4a532610d5392"
    scriptFile = file("gradle/gradlew")
}
