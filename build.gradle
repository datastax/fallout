buildscript {
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }

    dependencies {
        classpath 'guru.nidi:graphviz-java:0.8.3'
        classpath 'net.sourceforge.plantuml:plantuml:1.2019.7'
    }

    dependencyLocking {
        // The JFrog repository mirror handles the dependencies for
        // com.github.johnrengelman.shadow incorrectly, resulting in
        // different buildscript-gradle.lockfiles depending on whether
        // we resolve against the mirror or maven central.  Solve the
        // problem for now by ignoring the transitive dependencies.
        ignoredDependencies.addAll(
            "org.apache.ant:*",
            "org.apache.logging.log4j:*",
            "org.codehaus.groovy:groovy-backports-compat23",
            "org.codehaus.plexus:plexus-utils",
            "org.jdom:jdom2",
            "org.ow2.asm:*",
            "org.vafer:jdependency"
        )
    }
}

plugins {
    id 'java'

    // This is both a library _and_ an application
    id 'java-library'
    id 'application'

    id 'jacoco'
    id "org.jetbrains.gradle.plugin.idea-ext" version "0.10"

    id "com.datastax.fallout.symlinks"
    id "com.datastax.fallout.externaltools"
    id "com.datastax.fallout.fork"
    id "com.datastax.fallout.git"
    id "com.datastax.fallout.docker"
    id "com.datastax.fallout.conventions.test"
    id "com.datastax.fallout.conventions.lint"
    id "com.datastax.fallout.conventions.kotlin"
    id "com.datastax.fallout.conventions.dependency-locking"
    id "com.datastax.fallout.conventions.common-root-project"

    id "com.github.johnrengelman.shadow" version "6.1.0"
    id "com.github.node-gradle.node" version "3.0.1"
    id "com.diffplug.spotless" version "5.11.0"

    id "de.undercouch.download" version "4.1.1"
    id "com.google.osdetector" version "1.6.2"

    // This appears to be the only assertj plugin that:
    // - handles dependencies correctly;
    // - generates a single entrypoint class;
    // - can generate assertions for non-project classes.
    id "com.waftex.assertj-generator" version "1.1.4"
}

import com.datastax.fallout.gradle.fork.Fork
import static com.datastax.fallout.gradle.Utils.camelCase
import static com.datastax.fallout.gradle.common.CascadeTaskKt.cascadeTask

group = 'com.datastax'
version = '0.1.0-SNAPSHOT'
mainClassName = 'com.datastax.fallout.service.FalloutService'

def javaModuleJvmArgs = [
    // Handle jackson reflection under Java 9+ (see
    // https://github.com/FasterXML/jackson-modules-base/issues/37#issuecomment-389581245)
    '--illegal-access=permit',
    '--add-opens', 'java.base/java.lang=ALL-UNNAMED',
    '--add-opens', 'java.base/java.nio=ALL-UNNAMED'
]

// This will be inserted into the fallout wrapper script
applicationDefaultJvmArgs = [
    '-XX:+HeapDumpOnOutOfMemoryError',
    '-XX:-OmitStackTraceInFastThrow',
    '-server',
    '-ea',
    '-Djava.util.concurrent.ForkJoinPool.common.parallelism=1024'
] + javaModuleJvmArgs

// In production, falloutctl sets heap sizes; when running within gradle
// we must set something larger than the default 512m
// (https://docs.gradle.org/current/userguide/build_environment.html#sec:configuring_jvm_memory)
// for the test and server processes:
ext.applicationGradleJvmArgs = applicationDefaultJvmArgs + ["-Xmx2G"]

description = """DataStax Fallout"""

def defaultPropertyValue(String name, Closure valueProvider) {
    if (!project.hasProperty(name)) {
        ext.set(name, valueProvider.call())
    }
    ext.get(name)
}

def defaultPropertyValue(String name, Object value) {
    defaultPropertyValue(name, { value })
}

allprojects {
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
        if (rootProject.hasProperty('showJavaCompilerWarnings')) {
            options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
        }
    }

    // Ensure that archive tasks have reproducible outputs: this allows
    // build caching and build avoidance.  See
    // https://docs.gradle.org/5.6.3/userguide/working_with_files.html#sec:reproducible_archives
    tasks.withType(AbstractArchiveTask) {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    tasks.withType(Zip) {
        zip64 = true
    }

    tasks.withType(JavaExec) {
        enableAssertions = true
    }
}

def dropwizardVersion = '2.0.+'

// Used by jepsen as well, so we define this at the project level
ext.jschVersion = "0.1.55"
def jschAgentProxyVersion = "0.0.9"

defaultTasks ':shadowJar'

sourceSets {
    testBase
    integrationTest
    cassandraAllShaded
}

configurations {
    testBaseImplementation.extendsFrom(implementation, testConventionsImplementationDeps)

    integrationTestImplementation.extendsFrom(testBaseImplementation)
    integrationTestRuntimeOnly.extendsFrom(testBaseRuntimeOnly, testConventionsRuntimeOnlyDeps)
    integrationTestCompileOnly.extendsFrom(testBaseCompileOnly)

    testImplementation.extendsFrom(testBaseImplementation)
    testRuntimeOnly.extendsFrom(testBaseRuntimeOnly, testConventionsImplementationDeps)
    testCompileOnly.extendsFrom(testBaseCompileOnly)
}

// Make the following sourceSets available
// for consumption as feature variants; see
// https://docs.gradle.org/current/userguide/cross_project_publications.html#sec:variant-aware-sharing
java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(11))

    registerFeature("testBase") {
        usingSourceSet(sourceSets.testBase)
    }
    registerFeature("test") {
        usingSourceSet(sourceSets.test)
    }
    registerFeature("cassandraAllShaded") {
        usingSourceSet(sourceSets.cassandraAllShaded)
    }
    registerFeature("integrationTest") {
        usingSourceSet(sourceSets.integrationTest)
    }
}

configurations.all {
    resolutionStrategy {
        // The transitive dependency
        // io.dropwizard.metrics:metrics-jersey2:4.1.28 brings in jersey-server
        // 2.35, while io.dropwizard:dropwizard-core depends on jersey
        // 2.33; the combination of the two versions causes SSE failures
        force("org.glassfish.jersey.core:jersey-server:2.33")
    }
}

dependencies {
    // The DataStax internal version of fallout uses this project as a
    // dependency, which is why several dependencies are exposed as api
    // dependencies rather than implementation dependencies

    api project(path: ':cassandra-all-shaded', configuration: 'shadow')
    api project(path: ':jepsen', configuration: 'shadow')

    cassandraAllShadedApi project(path: ':cassandra-all-shaded', configuration: 'shadow')

    api(platform("io.dropwizard:dropwizard-bom:${dropwizardVersion}"))
    api(platform("io.dropwizard:dropwizard-dependencies:${dropwizardVersion}"))
    api "io.dropwizard:dropwizard-core"
    implementation "io.dropwizard:dropwizard-views-mustache"
    implementation "io.dropwizard:dropwizard-assets"
    api "io.dropwizard:dropwizard-auth"
    api "io.dropwizard:dropwizard-logging"
    api "io.dropwizard:dropwizard-metrics-graphite"

    api "com.google.guava:guava"
    api "com.github.spullara.mustache.java:compiler"

    implementation "org.eclipse.jetty:jetty-rewrite"

    implementation "com.jcraft:jsch:${jschVersion}"
    implementation "com.jcraft:jsch.agentproxy.jsch:${jschAgentProxyVersion}"
    implementation "com.jcraft:jsch.agentproxy.sshagent:${jschAgentProxyVersion}"
    implementation "com.jcraft:jsch.agentproxy.usocket-jna:${jschAgentProxyVersion}"

    api "commons-io:commons-io:2.+"
    api "org.yaml:snakeyaml:1.+"
    implementation("com.h2database:h2:1.4.+") {
        because("InMemoryCsvCheck uses this")
    }
    implementation "javax.mail:javax.mail-api:1.6.+"
    implementation "com.sun.mail:javax.mail:1.6.+"
    api "org.apache.commons:commons-csv:1.+"
    api("io.netty:netty-common:4.1.+") {
        because "HashedWheelTimer is used in several places"
    }
    implementation "com.fasterxml.jackson.core:jackson-annotations"
    implementation "org.apache.httpcomponents:httpclient:4.5.13"
    implementation "org.apache.commons:commons-math3:3.6.1"

    api "org.hdrhistogram:HdrHistogram:2.1.12"
    api 'com.github.pingtimeout:HdrLogProcessing:274e279'

    // Swagger
    implementation("io.dropwizard:dropwizard-views-freemarker") {
        because "Freemarker rendering is used by the dropwizard swagger bundle"
    }

    // See https://github.com/smoketurner/dropwizard-swagger/releases
    //
    // Waiting for fix of
    // https://github.com/smoketurner/dropwizard-swagger/issues/210 be
    // released before we move any higher than 2.0.0-1.  Once that has
    // been done, remove the constraint on
    // io.swagger:swagger-jersey2-jaxrs:1.5.x.
    implementation ("com.smoketurner:dropwizard-swagger:2.0.0-1")
    constraints {
        implementation('io.swagger:swagger-jersey2-jaxrs') {
            version {
                strictly '1.5.13'
            }
            because 'later versions bring in reflections 0.9.11, triggering ' +
                'https://github.com/smoketurner/dropwizard-swagger/issues/171 ' +
                '(fixed in com.smoketurner:dropwizard-swagger:2.0.12-1)'
        }
    }

    // Server-Sent Events
    implementation "org.glassfish.jersey.media:jersey-media-sse"
    implementation("org.glassfish.jersey.security:oauth2-client") {
        // Prevent the Jersey JacksonFeature (which overrides the Dropwizard
        // one) from being found and registered.
        // See https://github.com/dropwizard/dropwizard/issues/1341
        exclude(group: "org.glassfish.jersey.media", module: "jersey-media-json-jackson")
    }
    implementation "javax.ws.rs:javax.ws.rs-api:2.1.1"

    // AutoService
    def autoServiceVersion = '1.0'
    annotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"
    testAnnotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"
    testBaseAnnotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"

    implementation "com.google.auto.service:auto-service-annotations:${autoServiceVersion}"

    // AutoValue
    def autoValueVersion = '1.7.5'
    annotationProcessor "com.google.auto.value:auto-value:${autoValueVersion}"
    testAnnotationProcessor "com.google.auto.value:auto-value:${autoValueVersion}"
    integrationTestAnnotationProcessor "com.google.auto.value:auto-value:${autoValueVersion}"

    implementation "com.google.auto.value:auto-value-annotations:${autoValueVersion}"
    testImplementation "com.google.auto.value:auto-value-annotations:${autoValueVersion}"
    integrationTestImplementation "com.google.auto.value:auto-value-annotations:${autoValueVersion}"

    // Compile against the main classes, but leave it up to the
    // test configuration to specify where the runtime is (test
    // will already use sourceSets.main.output by default).
    testBaseCompileOnly sourceSets.main.output

    testBaseApi "org.awaitility:awaitility:4.0.3"

    testBaseApi(platform("io.dropwizard:dropwizard-bom:${dropwizardVersion}"))
    testBaseApi(platform("io.dropwizard:dropwizard-dependencies:${dropwizardVersion}"))

    testBaseImplementation "io.dropwizard:dropwizard-logging"
    testBaseApi("io.dropwizard:dropwizard-testing") {
        exclude group: "junit", module: "junit"
    }

    testImplementation sourceSets.testBase.output
    testApi "org.apache.sshd:sshd-core:1.7.0"
    testApi "org.mockito:mockito-core:3.8.0"
    testApi 'org.mockito:mockito-junit-jupiter:3.8.0'
    testApi "org.quicktheories:quicktheories:0.26"
    testImplementation('com.github.tomakehurst:wiremock:2.27.2'){
        exclude group: 'com.fasterxml.jackson.core'
    }
    // Needed for ClojureShutdownListener
    testImplementation "org.junit.platform:junit-platform-launcher"

    implementation('com.google.cloud:google-cloud-logging:2.2.0') {
        exclude group: 'com.google.guava', module: 'guava'
    }

    integrationTestImplementation sourceSets.testBase.output
    integrationTestRuntimeOnly tasks.jar.outputs.files
}

// ----------------------------------------------------------------------------
// Git support

task setupGit {
    def config = [
        "core.hooksPath": "git-hooks" ,
        "core.whitespace": "blank-at-eol,space-before-tab,tab-in-indent,trailing-space"
    ]
    doLast {
        config.each { key, value ->
            exec {
                commandLine("git", "config", key, value)
            }
        }
        exec {
            commandLine("git", "secrets", "--register-aws")
        }
        exec {
            commandLine("git", "secrets", "--add-provider", "--",
                "grep", "-E", "-v", "^[[:space:]]*(#.*)?\$", ".gitforbidden")
        }
    }
}

// ----------------------------------------------------------------------------
// Compilation

// Supporting @JsonCreator with implicit named parameters requires
// that we store the parameter names in the generated class files
// (https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html):
tasks.withType(JavaCompile) {
    options.compilerArgs += '-parameters'
}

// ----------------------------------------------------------------------------
// IDEA integration

idea {
    module {
        // Exclude directories that are ignored in .gitignore; this should be
        // automatic, but it isn't: see
        // https://youtrack.jetbrains.com/issue/IDEA-140714
        excludeDirs += [
            // Ignore files created by running fallout/cassandra in
            // the current directory
            file('tests'), file('cassandra'), file('run'), file('logs'),

            // Nothing creates tmp, but it's a convenient place to keep
            // temporary things
            file('tmp')
        ]
    }
}

def ideaVersion = System.getProperty('idea.version')

if (ideaVersion) {

    def (major, minor) = ideaVersion.split("\\.").collect { it.toInteger() }

    // IDEA 2019 defines idea.version for _all_ gradle invocations; prior
    // versions only defined it when importing.  2019 additionally
    // defines sync.active when importing.
    def importing = major < 2019 || System.getProperty('idea.sync.active');

    if (importing) {

        println "Detected IDEA ${ideaVersion} Sync"

        // IDEA used to incorrectly use the annotation processor classpath as
        // "Provided", which means that any library versions in the annotation
        // processor classpath override the versions in the implementation
        // classpath.  This is no longer the case in 2020.3; it may have
        // been fixed earlier
        if (major < 2020 || (major == 2020 && minor < 3)) {
            println "Fixing incorrect annotation processor classpaths"
            dependencies {
                annotationProcessor configurations.implementation
                testAnnotationProcessor configurations.testImplementation
            }
        }

        // IDEA < 2019.3 searches for annotation processors on the classpath,
        // and doesn't use the annotationProcessor configuration,
        // so we add it here.
        if (major < 2019 || (major == 2019 && minor < 3)) {
            println "Adding annotation processor classpaths"
            idea {
                module {
                    scopes.each {
                        it.value.plus += [configurations.annotationProcessor]
                    }
                }
            }
        }
    }
}

// ----------------------------------------------------------------------------
// Convenience

task publish {
    group 'publish'
    description "Publish all artifacts that make up a release"
}

// ----------------------------------------------------------------------------
// Run cassandra as a standalone process

def cassandraVersion = "2.1.21"

configurations {
    cassandraStandalone
}

dependencies {
    cassandraStandalone 'org.jmxtrans.agent:jmxtrans-agent:1.2.8'
    cassandraStandalone "org.apache.cassandra:cassandra-all:${cassandraVersion}"
}

// Dummy rendezvous task
task cassandraStopped

task startCassandra(type: Fork) {
    def pidFile = file("${project.rootDir}/run/cassandra.pid")
    def java8Home = System.getenv('JAVA8_HOME')
    def classPath = configurations.cassandraStandalone.asPath
    def cassandraYaml = "${project.rootDir}/src/main/resources/cassandra.yaml"
    def logbackXml = "${project.rootDir}/etc/cassandra/logback.xml"
    def logDir = "${project.rootDir}/logs/cassandra"

    doFirst {
        if (!java8Home) {
            throw new GradleException("JAVA8_HOME must be set to run startCassandra task")
        }
    }

    workingDir "${project.rootDir}"
    commandLine "${java8Home}/bin/java",
        "-classpath", classPath,
        "-XX:+HeapDumpOnOutOfMemoryError", "-Xms8G", "-Xmx8G", "-server", "-ea",
        "-Dcassandra.config=file://${cassandraYaml}",
        "-Dcassandra-pidfile=${pidFile}",
        "-Dcassandra.logdir=${logDir}",
        "-Dlogback.configurationFile=${logbackXml}",
        "org.apache.cassandra.service.CassandraDaemon"

    doLast {
        def waitSeconds = 60
        def port = 9096
        def portOpened = false

        while (!portOpened && waitSeconds && !processHandle.state.terminal) {
            try {
                def socket = new Socket("localhost", port);
                socket.close()
                portOpened = true
            }
            catch (ConnectException e) {
            }
            waitSeconds -= 1
            Thread.sleep(1000)
        }

        if (processHandle.state.terminal) {
            throw new GradleException("Cassandra exited with code ${processHandle.waitForFinish().exitValue}")
        }

        if (!portOpened) {
            processHandle.abort()
            throw new GradleException("Cassandra didn't start listening on ${port} within ${waitSeconds} seconds")
        }
    }
}

task stopCassandra {
    finalizedBy cassandraStopped
    doFirst {
        startCassandra.processHandle.abort()
        startCassandra.processHandle.waitForFinish()
    }
}

// ----------------------------------------------------------------------------
// Git

git.describeTagPattern = "fallout-*.*.*"

// ----------------------------------------------------------------------------
// Generated resources

def generatedResourcesOutputDir = file("${buildDir}/src/main/resources")

sourceSets {
    main {
        resources {
            srcDirs += generatedResourcesOutputDir
        }
    }
}

// LESS

node {
    download = true
    version = "16.1.0"

    // Prevent the node extension from declaring a repository: see
    // https://github.com/node-gradle/gradle-node-plugin/blob/6f03c21e7e51189885a384ab533ee191c971f7dc/docs/faq.md#is-this-plugin-compatible-with-centralized-repositories-declaration
    distBaseUrl = null
}

task lessCompile(type: NpxTask) {
    dependsOn npmInstall
    def source = file("src/main/resources/assets/less/fallout.less")
    def target = file("${generatedResourcesOutputDir}/assets/css/fallout.css")

    // The lessCompile task doesn't declare inputs or outputs, so we do it here
    inputs.files fileTree("src/main/resources/assets/less")
    outputs.file target

    command = "lessc"
    args = ["$source", "$target"]
}

processResources.dependsOn(lessCompile)

// Version HTML file

task generateVersionFile() {
    ext.target = file("${generatedResourcesOutputDir}/assets/pages/version.html")
    ext.targetContent = """
        <dl>
        <dt>branch:
        <dd><a href="https://github.com/${git.repo}/tree/${git.branch}">${git.branch}</a>
        <dt>commit:
        <dd><a href="https://github.com/${git.repo}/commit/${git.commit}">${git.commit}</a>
        </dl>
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

// fallout-client installers

task generateCliInstaller() {
    ext.target = file("${generatedResourcesOutputDir}/assets/installers/cli")
    ext.targetContent = """
        pipx install --python python3 --force "git+ssh://git@github.com/${git.repo}.git@${git.commit}#egg=fallout-client&subdirectory=fallout-cli"
    """

    inputs.property('content', targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

task generateApiInstaller() {
    ext.target = file("${generatedResourcesOutputDir}/assets/installers/api")
    ext.targetContent = """
        python3 -m pip install --upgrade "git+ssh://git@github.com/${git.repo}.git@${git.commit}#egg=fallout-client&subdirectory=fallout-cli"
    """

    inputs.property('content', targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

processResources.dependsOn(generateVersionFile, generateCliInstaller, generateApiInstaller)

// ----------------------------------------------------------------------------
// Generated sources

def generatedSourcesOutputDir = file("${buildDir}/src/main/java")

sourceSets {
    main {
        java {
            srcDirs += generatedSourcesOutputDir
        }
    }
}

// Annotation processors

sourceSets.each { sourceSet ->
    if (sourceSet.compileJavaTaskName != null) {
        tasks[sourceSet.compileJavaTaskName].configure {
            options.annotationProcessorGeneratedSourcesDirectory =
                file("${buildDir}/src/${sourceSet.name}/java-annotation-processors")
        }
    }
}

// Internal version string

task generateVersionJavaFile {
    ext.target = file("${generatedSourcesOutputDir}/com/datastax/fallout/FalloutVersion.java")
    ext.targetContent = """
        package com.datastax.fallout;

        public class FalloutVersion {
            public static String getVersion() { return "${git.describe}"; }
            public static String getCommitHash() { return "${git.commit}"; }
        }
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

compileJava.dependsOn(generateVersionJavaFile)

// ----------------------------------------------------------------------------
// AssertJ custom assertion generation

assertjGenerator {
    classOrPackageNames = [
        'com.datastax.fallout.harness.TestResult',
        'com.datastax.fallout.ops.NodeGroup',
        'com.datastax.fallout.ops.commands.NodeResponse',
        'com.datastax.fallout.runner.CheckResourcesResult',
        'com.datastax.fallout.service.core.Test',
        'com.datastax.fallout.service.core.TestRun',
        'com.datastax.fallout.service.core.User',
        'javax.ws.rs.core.Response',
        'javax.ws.rs.core.Response$StatusType']

    entryPointPackage = "com.datastax.fallout.assertj"
    outputDir = file("${buildDir}/src/testBase/java")
    testSourceSet = sourceSets.testBase
}

// ----------------------------------------------------------------------------
// Distribution and packaging

["startScripts", "startShadowScripts"]
    .collect { tasks[it] }
    *.configure {

        // Insert FALLOUT_HOME and PATH into the default start script before
        // the final "exec" line that runs java.  It's _possible_ to work out
        // where the java executable is running from within the code, but it's more
        // involved and less reliable than doing it from the wrapper.
        doLast {
            unixScript.text = unixScript.text.replaceFirst(~'(\nexec .*\\s*$)', {
                '''
    export FALLOUT_DIST="$APP_HOME"
    export FALLOUT_HOME="${FALLOUT_HOME:-$FALLOUT_DIST}"
    export PATH="$FALLOUT_DIST/bin:$PATH"
    ''' + it[0]
            })
        }
    }

// External tools

externalTools {
    configuration("main") {
        binary("kubectl") {

            // See https://kubernetes.io/docs/tasks/tools/install-kubectl
            // for location of binaries and checksums

            platforms(["linux", "darwin"]) {
                source.set("https://dl.k8s.io/release/v1.21.0/bin/${platform}/amd64/kubectl")
            }

            platform("linux") {
                checksum.set("9f74f2fa7ee32ad07e17211725992248470310ca1988214518806b39b1dad9f0")
            }

            platform("darwin") {
                checksum.set("f9dcc271590486dcbde481a65e89fbda0f79d71c59b78093a418aa35c980c41b")
            }
        }

        tarball("helm") {
            // https://github.com/helm/helm/releases

            platforms(["linux", "darwin"]) {
                source.set("https://get.helm.sh/helm-v3.5.4-${platform}-amd64.tar.gz")
                unpackedBinDir.set("${platform}-amd64")
            }

            platform("linux") {
                checksum.set("a8ddb4e30435b5fd45308ecce5eaad676d64a5de9c89660b56face3fe990b318")
            }

            platform("darwin") {
                checksum.set("072c40c743d30efdb8231ca03bab55caee7935e52175e42271a0c3bc37ec0b7b")
            }
        }

        tarball("gcloud") {
            // https://console.cloud.google.com/storage/browser/cloud-sdk-release for all versions;
            // https://cloud.google.com/sdk/docs/install for current

            platforms(["linux", "darwin"]) {
                source.set("https://dl.google.com/dl/cloudsdk/channels/rapid/" +
                    "downloads/google-cloud-sdk-341.0.0-${platform}-x86_64.tar.gz")
                unpackedBinDir.set("google-cloud-sdk/bin")
            }

            platform("linux") {
                checksum.set("baafb8415d0d1c909c229ad704b1b05de57e10cddabc4fdf8018db4bcf02ab45")
            }

            platform("darwin") {
                checksum.set("e7c13e1159b9a9652b2fb96b776f73b58f145fb53e0d4c13c4cba1a6dd01b800")
            }
        }
    }

    configuration("test") {
        binary("kind") {
            // https://github.com/kubernetes-sigs/kind/releases

            platforms(["linux", "darwin"]) {
                source.set("https://kind.sigs.k8s.io/dl/v0.10.0/kind-${platform}-amd64")
            }

            platform("linux") {
                checksum.set("74767776488508d847b0bb941212c1cb76ace90d9439f4dee256d8a04f1309c6")
            }

            platform("darwin") {
                checksum.set("a934e573621917a2785f3ddfa7b6187d18fa1c20c94c013919736b3256d37f57")
            }
        }
    }
}

def currentOs = osdetector.os

defaultPropertyValue("externalTestToolsDir", "${buildDir}/externalTestTools")

["linux", "osx"].each { osName ->

    // The same as the standard distribution plus the external-tools
    distributions.create(osName) {
        contents {
            with distributions.main.contents
            from(project.externalTools.configuration("main").platform(osName).installTask)
        }
    }

    distributions.create(camelCase("shadow", osName)) {
        contents {
            with distributions.shadow.contents
            from(project.externalTools.configuration("main").platform(osName).installTask)
        }
    }
}

distributions.create("native") {
    contents {
        with distributions[currentOs].contents
    }
}

distributions.create("shadowNative") {
    contents {
        with distributions[camelCase("shadow", currentOs)].contents
    }
}

distributions.matching { dist ->
    dist.name == "main" || dist.name == "shadow"  }
    *.contents {

        // Cassandra standalone support
        from(configurations.cassandraStandalone) {
            into('lib/cassandra-standalone')
        }
        from("etc/cassandra") {
            into('lib/cassandra-standalone')
        }
        from("src/main/resources") {
            include "cassandra.yaml"
            into('lib/cassandra-standalone')
        }

        // Include the nginx config support files
        from('etc/nginx') {
            into('nginx')
        }

        // Include tool support scripts
        from('tools/support') {
            into('lib/tools/support')
        }
    }

// Include python sources for tools
subprojects { subproject ->
    subproject.afterEvaluate {
        if (subproject.ext.has('isPythonTool')) {
            distributions
                .matching { dist ->
                    dist.name == "main" || dist.name == "shadow"
                }
                *.contents {
                    from(subproject.toolContents) {
                        into "lib/tools/${subproject.toolCategory}/${subproject.toolName}"
                    }
                }
        }
    }
}

// Ensure shadowJar correctly merges all the service files and also
// caches the output (it doesn't by default)
shadowJar {
    mergeServiceFiles()

    manifest {
        attributes('Implementation-Version': git.describe)
    }

    outputs.cacheIf { true }
}

// ----------------------------------------------------------------------------
// Docker

docker {
    imageFiles.from(installShadowLinuxDist)
    tagName = "datastax/fallout"
    // Use the git version without the "fallout-" prefix e.g. "fallout-1.2.3" -> "1.2.3"
    tagVersion = git.describe.replaceFirst(/^[a-z-]*/, "")
    composeEnvironment.put("CASSANDRA_VERSION", cassandraVersion)
    if (osdetector.os == "osx") {
        composeEnvironment.put("SSH_AUTH_SOCK", "/run/host-services/ssh-auth.sock")
    }
}

publish.dependsOn(dockerPush)

// ----------------------------------------------------------------------------
// Tests

// Dummy rendezvous task to allow builds that compose this build to
// serialize tests
task allTestsFinished

// Pick up any and all generated coverage files
// https://github.com/gradle/gradle/issues/5898#issuecomment-554600486
jacocoTestReport {
    getExecutionData().setFrom(fileTree(buildDir).include("/jacoco/*.exec"))
}

defaultPropertyValue("testToolsRunDir", "${buildDir}/testToolsRun")

task installToolsForTesting {
    dependsOn(externalTools.installAllNativeTask)
}

subprojects {
    rootProject.installToolsForTesting {
        dependsOn tasks.matching { it.name == "installToolForTesting" }
    }
}

allprojects {
    // Make sure we delete any generated coverage files before running any
    // test; if we don't, then coverage reports can include data from test
    // tasks that weren't run as part of the current gradle invocation
    task cleanJacocoOutputs(type: Delete) {
        delete jacocoTestReport.executionData
    }

    tasks.withType(Test) {
        dependsOn(installToolsForTesting)

        environment "PATH", "${externalTools.nativePath}:${System.getenv('PATH')}"
        environment "FALLOUT_TOOLS_DIR", "${testToolsRunDir}/tools"

        jvmArgs = project.applicationGradleJvmArgs

        [
            "runExpensiveTests",
            "runTestsThatCostMoney",
            "skipCCMTests"
        ].each { property ->
            if (rootProject.hasProperty(property)) {
                systemProperty property, true
            }
        }

        // Pass through any -Plog.... settings as system properties
        // (see LogbackConfigurator.java)
        rootProject.properties.each { k, v ->
            if (k =~ /log\..*/) {
                systemProperty k, v
            }
        }

        // Ensure the whole test framework uses the slf4j bridge by setting it
        // in the below properties file; if we don't do this, then there'll
        // be a period of time where the java.util.logging framework is used
        // before gradle manually installs the slf4j bridge
        systemProperties += [
            'java.util.logging.config.file':
                "${project.rootDir}/src/testBase/resources/java.util.logging.properties"
        ]

        def jacocoPluginApplied = extensions.findByType(JacocoTaskExtension)
        if (jacocoPluginApplied) {

            // Generating coverage data has a non-negligible runtime cost, so we
            // don't enable it by default
            def generateCoverageData = rootProject.hasProperty('generateCoverageData')

            jacoco {
                enabled = generateCoverageData
            }

            if (generateCoverageData) {
                dependsOn cleanJacocoOutputs
                finalizedBy jacocoTestReport
            }
        }
    }
}

test {
    useJUnitPlatform {
        excludeTags "requires-db"
    }

    testClassesDirs = testClassesDirs.plus(
        sourceSets.testBase.output.classesDirs)

    finalizedBy allTestsFinished
}

task dbTest(type: Test) {
    description = 'Starts a local DB instance and runs tests marked RequiresDb.'
    group = 'verification'

    useJUnitPlatform {
        includeTags "requires-db"
    }

    dependsOn startCassandra
    finalizedBy stopCassandra, allTestsFinished

    mustRunAfter test
}

["check", "cleanCheck"].each { taskName ->
    cascadeTask(project, tasks.named(taskName))
}

// ----------------------------------------------------------------------------
// Running development versions

def nginxStandaloneDir = file("${buildDir}/nginx-standalone")

task generateStandaloneNginxFalloutYml {
    ext.falloutYml = file("fallout.yml")
    ext.generatedFalloutYml = file("${nginxStandaloneDir}/fallout.yml")

    inputs.file falloutYml
    outputs.file generatedFalloutYml

    doLast {
        generatedFalloutYml.getParentFile().mkdirs()
        generatedFalloutYml.withOutputStream { out ->
            if (falloutYml.exists()) {
                falloutYml.withInputStream {
                    out << it.filterLine {
                        !it.contains("useNginxToServeArtifacts")
                    }
                }
            }
            out << "\nuseNginxToServeArtifacts: true"
        }
    }
}

task generateStandaloneNginxConf(type: JavaExec, dependsOn: [compileJava, generateStandaloneNginxFalloutYml]) {
    ext.nginxConf = file("${nginxStandaloneDir}/nginx.conf")
    ext.nginxHtml = file("etc/nginx/html")

    outputs.file nginxConf

    main run.main
    classpath run.classpath
    args 'generate-nginx-conf',
        '--standalone',
        '--nginx-listen-port', '8090',
        '--output', nginxConf,
        generateStandaloneNginxFalloutYml.generatedFalloutYml, nginxHtml
}

task startStandaloneNginx(type: Fork, dependsOn: generateStandaloneNginxConf) {
    commandLine "nginx", "-p", nginxStandaloneDir, "-c", generateStandaloneNginxConf.nginxConf
}

task stopStandaloneNginx {
    doFirst {
        startStandaloneNginx.processHandle.abort()
    }
}

class RunServer extends JavaExec {
    RunServer() {
        main = project.tasks.run.main
        classpath = project.tasks.run.classpath
        group = "application"

        dependsOn(project.tasks.installToolsForTesting)

        environment "PATH", "${project.externalTools.nativePath}:${System.getenv('PATH')}"
        environment "FALLOUT_TOOLS_DIR", "${project.ext.testToolsRunDir}/tools"

        jvmArgs project.applicationGradleJvmArgs
        if (project.hasProperty("devmode")) {
            jvmArgs jvmArgs + ['-Dfallout.devmode=true']
        }
    }
}

task runServerWithNginx(type: RunServer) {
    description "Run the fallout server and nginx, " +
        "using nginx to serve artifacts"

    dependsOn startStandaloneNginx, startCassandra
    finalizedBy stopCassandra, stopStandaloneNginx

    args 'standalone', generateStandaloneNginxFalloutYml.generatedFalloutYml
}

task runServer(type: RunServer) {
    description "Run the fallout server"

    ext.falloutYml = file("fallout.yml")
    inputs.files falloutYml

    dependsOn startCassandra
    finalizedBy stopCassandra

    if (falloutYml.exists()) {
        args 'standalone', falloutYml
    }
    else {
        args 'standalone'
    }
}
task runServerInDocker {
    group 'docker'
    description "Run the fallout server docker image using docker-compose"

    dependsOn "dockerComposeUp"
    finalizedBy "dockerComposeDown"

    // Gradle won't run finalizers on ctrl-C, and it won't pass the
    // SIGINT thus generated to child processes (it uses destroyForcibly
    // == SIGTERM), so we can't just make this task run plain
    // "docker-compose up" and allow ctrl-C to do graceful shutdown.
    doFirst {
        println "Fallout server is running; press <RETURN> to terminate."
        println "Will start log tailing in a moment..."

        // Give people a chance to see the above message
        Thread.sleep(5000)

        def dockerComposeLogs = project.procs.fork {
            commandLine "docker-compose", "-f", dockerComposeFile, "logs", "--follow"
        }

        System.in.read();

        dockerComposeLogs.abort()
    }
}

// ----------------------------------------------------------------------------
// Create a custom jar with a different FalloutVersion for the purpose of
// deployment testing

def generatedDeploymentTestSourcesOutputDir = file("${buildDir}/src/deploymentTestVersion/java")

sourceSets {
    deploymentTest {
        java {
            srcDirs += generatedDeploymentTestSourcesOutputDir
        }
    }
}

task generateDeploymentTestVersionJavaFile {
    ext.target = file("${generatedDeploymentTestSourcesOutputDir}/com/datastax/fallout/FalloutVersion.java")
    ext.targetContent = """
        package com.datastax.fallout;

        public class FalloutVersion {
            public static String getVersion() { return "DEPLOYMENT_TEST"; }
            public static String getCommitHash() { return "DEPLOYMENT_TEST"; }
        }
    """

    inputs.property("content", targetContent)
    outputs.file target

    doLast {
        target.getParentFile().mkdirs()
        target.text = targetContent
    }
}

compileDeploymentTestJava.dependsOn(generateDeploymentTestVersionJavaFile)

// Create a jar that contains all but the FalloutVersion from the main
// sourceset, and the FalloutVersion we build for deployment testing
task deploymentTestJar(type: Jar) {
    from(sourceSets.main.output) {
        exclude "**/FalloutVersion.*"
    }
    from(sourceSets.deploymentTest.output)
    archiveFileName = "fallout-deploymentTest.jar"
}

// ----------------------------------------------------------------------------
// Integration tests

task integrationTest(type: Test, dependsOn: [dockerBuild]) {
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath

    systemProperties([
        dockerLatestTag: docker.latestTag.get(),
        falloutVersion: git.describe
    ])

    mustRunAfter(test, dbTest, stopCassandra)
    finalizedBy allTestsFinished
}

// ----------------------------------------------------------------------------
// Cleanliness

spotless {
    java {
        custom 'prefer generated assertj entry point', { str ->
            str.replace('import static org.assertj.core.api.Assertions.',
                'import static com.datastax.fallout.assertj.Assertions. ')
        }

        // The spotless import ordering plugin is based on the eclipse one;
        // it's not as advanced as IntelliJ, in that it _always_ inserts a
        // blank line between groups, and matches imports by longest
        // matching prefix: there's no wildcard matching.
        // An empty group ('') matches everything.
        // '\\#' matches static imports.
        //
        // If you change this, you should also change the import order in
        // ij_java_imports_layout in .editorconfig.
        //
        // This ordering is pragmatic rather than anything else; it matches
        // the ordering that most of the codebase already had before we started
        // enforcing it.
        importOrder(
            'javax.', 'java.', '', 'com.datastax.', 'org.apache.cassandra.', '\\#')
        removeUnusedImports()

        endWithNewline()
        trimTrailingWhitespace()
        eclipse().configFile("eclipse-format.prefs")
        licenseHeaderFile "gradle/LicenseHeader.java"

        target "src/*/java/**/*.java"
    }
}

tasks.named("lint").configure {
    dependsOn(spotlessCheck)
}

test {
    shouldRunAfter spotlessCheck
}

// ----------------------------------------------------------------------------
// Diagrams; we use a graphviz library to generate a PNG, and plantuml for
// sequence diagrams

import guru.nidi.graphviz.engine.Graphviz
import guru.nidi.graphviz.engine.Format

task dumpNodeGroupStatesToDot(type: JavaExec) {
    group "documentation"

    ext.dotFile = file("${buildDir}/node-group-states.dot")
    description "Create a DOT diagram of node states in ${dotFile}"

    dependsOn compileJava
    outputs.file dotFile

    main = 'com.datastax.fallout.ops.DumpNodeGroupStatesToDot'
    classpath = sourceSets.main.runtimeClasspath
    args = [dotFile]
}

def renderDotFile(dotFile, pngFile) {
    Graphviz.fromFile(dotFile).render(Format.PNG).toFile(pngFile)
}

task dumpNodeGroupStatesToPng {
    group "documentation"

    dependsOn dumpNodeGroupStatesToDot
    inputs.files dumpNodeGroupStatesToDot
    outputs.file file("docs/node-group-states.png")

    description "Create a PNG diagram of node states in " +
        "${outputs.files.singleFile}"

    doLast {
        renderDotFile(inputs.files.singleFile, outputs.files.singleFile)
    }
}

task renderDocsDots {
    group "documentation"
    description "Creates PNGs from DOT source files in docs/assets"

    inputs.files fileTree(dir: "docs/assets", include: "*.dot")
    outputs.files inputs.files.collect { f -> file(f.path.replace(".dot", ".png")) }
    doLast {
        inputs.files.each { f ->
            renderDotFile(f, file(f.path.replace(".dot", ".png")))
        }
    }
}

// I couldn't make https://github.com/cosminpolifronie/gradle-plantuml-plugin
// work as of 1.6.0, so we're hand-rolling this like the dot support above:

import net.sourceforge.plantuml.SourceStringReader
import net.sourceforge.plantuml.FileFormatOption
import net.sourceforge.plantuml.FileFormat

def renderPlantUmlFile(plantUmlFile, pngFile) {
    pngFile.withOutputStream { out ->
        new SourceStringReader(plantUmlFile.text)
            .outputImage(out, new FileFormatOption(FileFormat.PNG, true))
    }
}

task renderDocsPlantUmls {
    group "documentation"
    description "Creates PNGs from plantuml source files in docs/assets"

    inputs.files fileTree(dir: "docs/assets", include: "*.plantuml")
    outputs.files inputs.files.collect { f -> file(f.path.replace(".plantuml", ".png")) }
    doLast {
        inputs.files.each { f ->
            renderPlantUmlFile(f, file(f.path.replace(".plantuml", ".png")))
        }
    }
}

task docs(dependsOn: [dumpNodeGroupStatesToPng, renderDocsDots, renderDocsPlantUmls]) {
    group "documentation"
    description "Run all documentation tasks except javadoc"
}

// ----------------------------------------------------------------------------

wrapper {
    // https://gradle.org/release-checksums/
    gradleVersion = "7.3.2"
    distributionSha256Sum = "23b89f8eac363f5f4b8336e0530c7295c55b728a9caa5268fdd4a532610d5392"
}
